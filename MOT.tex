\section{MAINTAINABILITY OPPORTUNITY TREE}
\label{sec:opportunity_tree}
Figure \ref{fig:opportunity_tree} provides an opportunity tree for Maintainability.   As with our other opportunity trees for reducing Cost, reducing Schedule, and improving Dependability aspects, it provides a checklist for systems engineers and developers to use in improving a system's Maintainability.


\begin{figure}[h]
	\vspace{-0.3cm}
	\centering
	\resizebox{\columnwidth}{!}{
		\begin{tikzpicture}[grow'=right,level distance=2.2in,sibling distance=.05in]
		\tikzset{
			edge from parent/.style= 
			{thick, draw, edge from parent fork right},
			every tree node/.style=
			{draw,minimum width=2in,text width=2in,align=left},
		}
		\begin{scope}
		\Tree 
		[.{Anticipate\ Maintainability\ Needs}
		[.{Maintainer\ Involvement} ]
		[.{Evolution\ Information} ]
		[.{Trend\ Analysis} ]
		[.{Hotspot\ (Change\ Source)\ Analysis} ]
		]
		\end{scope}
		\begin{scope}[yshift=-2.8cm]
		\Tree
		[.Design/Develop\ for\ Maintainability
		[.{Modularize\ Around\ Hotspots} ]
		[.{Service-Oriented;\ Set-Based\ Design} ]
		[.{Continuous\ Technial\ Debt\ Analysis,\ Reduction} ]
		[.{Enable\ User\ Programmability} ]
		]
		\end{scope}
		\begin{scope}[yshift=-5.3cm]
		\Tree
		[.Improve\ Maintainability\ V\&V
		[.{Value-Based\ V\&V\ Prioritization} ]
		[.{Improved\ Defect\ Diagnosis} ]
		[.{Regression\ Test\ Capabilities;\ DevOps} ]
		]  
		\end{scope}
		\end{tikzpicture}
	}
	\caption{Maintainability Opportunity Tree}
	\label{fig:opportunity_tree}
\end{figure}



\textbf{Anticipate Maintainability Needs: Maintainer Involvement.}
Lack of maintainer involvement in system and software development often results in key Maintainability enablers being either neglected or implemented in incompatible ways.   It may take some effort to get the maintainers involved, as often they are stuck in a vicious circle and are too busy overcoming the Maintainability shortfalls caused by previous projects lacking maintainer involvement in their definition and development.

\textbf{Evolution Information and Trend Analysis.}
Often, the requirements for a system acquisition are determined by prioritizing the capabilities, and using a Cost As Independent Variable (CAIV) analysis to determine which capabilities fit within the available budget and are to be included in the Request for Proposal (RFP).   This unfortunately throws away valuable below-the-line information on the most likely directions of system evolution, often leading to a brittle point-solution architecture as the chosen solution.
Including the below-the-line capabilities in the RFP as candidate Evolution Capabilities Information, and indicating that it should be considered in preparing the system's life cycle architecture, is more likely to result in reducing operations and maintenance costs.
Trend Analysis is another way to identify likely directions of system evolution.

\textbf{Hotspot (Change Source) Analysis.} Common sources of change include user interface changes, device driver changes, external interface changes, and changes in Non-Developmental Items (NDIs).
Many Commercial-Off-The-Shelf (COTS) NDI products have new releases every 8-12 months, and continue support for only the latest three releases.  In gathering data for a COTS-integration version of the COCOMO cost model, we found one large project entering maintenance with 120 COTS products, 55 of which were no longer supported \cite{Abts00cocots:a}.  Other NDIs are more volatile: for example, Amazon's cloud services are updated every 11 seconds.  Open-source NDIs vary widely on their change frequency.  Systems employing numerous COTS products, and NDIs may therefore have numerous changes, often becoming too expensive to maintain.

\textbf{Design/Develop for Maintainability: Modularization Around Hotspots.} The 1979 Parnas paper, ``Designing Software for Ease of Extension and Contraction,'' \cite{parnas1979designing} and earlier Parnas papers identify this Maintainability strategy.   Common sources of change that have been encapsulated in modules will contain the change effects within the module rather than having them ripple across the other parts of the system.    Using this and related TRW data-driven strategies enabled large projects to perform maintenance changes at lower costs than development changes \cite{royce1998software}.   

\textbf{Service Orientation; Set-Based Design.} Service-oriented loose coupling is a design principle that is applied to the services in order to ensure that the service contract is independent of the underlying service logic and implementation \cite{sundbo2000innovation}. Basically, the concept of loose coupling provided by a Service-Oriented Architecture (SOA) component is that it publishes a contract indicating that if it is furnished with a specified set of inputs, it will produce a specified set of outputs, without otherwise interacting with the user's environment \cite{boehm2008balancing,borges2004delving}.

If a project has a range of choices among services, algorithms, COTS products, etc., it is often better to identify the strongest sets of choices of each and carry them along in a set-based design and to converge on the best choices as sufficient information becomes available 
\cite{bernstein1998design,reinertsten2009principles}.  Set-based design is also valuable if a system is part of one or more systems of independently-evolving systems.

\textbf{Continuous Technical Debt Analysis and Reduction.}  Technical debt refers to delayed technical work or rework that is incurred when shortcuts are taken.  The shortcuts may have good rationales such as the need to meet a market window or to field defenses against cyber or physical attacks.  Or they may result from poor project coordination or sloppy work habits.  Examples are duplicated code or files; unused code; uninitialized variables; and unguarded exceptions.  Either way, the later the debt is paid, the more it will cost, corresponding to interest on a financial debt.

Finding such sources of technical debt via code inspections can be labor-intensive if done for each commit, or delayed if done for each release, although human-assessed indicators of software understandability have been shown to be helpful in estimating maintenance costs \cite{chen2016evaluating}.  Fortunately, tools are becoming available for assessing software technical debt, such as SonarQube, CAST, PMD, and FindBugs.  Section 3 will summarize the Software Quality Understanding by Analysis of Abundant Data (SQUAAD) toolset for tracking a software project's incremental code commits, and for analyzing and visualizing each commit's incremental and cumulative Technical Debt.

\textbf{Enable User Programmability.} In many circumstances, users have found it easier to develop spreadsheet applications for specific needs rather than trying to master and tailor complex general applications to fit their needs.   Many special devices with numerous options (e.g., medical infusion pumps; educational robots) have simple special-purpose languages for specifying the options.  User Programmability may have problems: an IBM study found that 44\% of a large sample of spreadsheet programs had defects that would if exercised have had major negative financial outcomes for the organization.

\textbf{Improve Maintainability V\&V: Value-Based V\&V Prioritization.}  Most V\&V aids, such as automated test case generation, assume that every test case and defect is equally important.  However, in practice, projects find that the value of running the test cases follows a Pareto distribution, in which 20\% of the test cases produce 80\% of the business value.  For example, one company found that one of its 15 customer sets accounted for 50\% of the business value of prompt billing, and 3 of its customer sets accounted for 80\% of the business value \cite{bullock2000calculating}.   A further industrial application increased the business value of testing their annual product release features from 58\% to 91\% \cite{li2012value}.

\textbf {Regression Test Capabilities; DevOps.}
Amazon's DevOps ability to reliably upgrade its huge variety of services every 11 seconds implies a remarkable ability to perform regression testing of each release's changes.  Providing similarly reliable, rapid large-scale DevOps upgrades will require similar rapid regression testing upgrades.  Software maintenance organizations expected to carry on similar DevOps capabilities would need similar rapid regression testing capabilities, along with further Testability enablers of having and evolving cost-effective test drivers, test oracles, test data management capabilities, and diagnostic capabilities.   





